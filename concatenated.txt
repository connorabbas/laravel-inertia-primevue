

==== app\Http\Controllers\Admin\Auth\AuthenticatedSessionController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Auth;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Route;
use App\Http\Requests\Admin\LoginRequest;
use Illuminate\Support\Facades\Log;

class AuthenticatedSessionController extends Controller
{
    /**
     * Display the login view.
     */
    public function create(): Response
    {
        Log::info('Admin login view displayed');
        return Inertia::render('Admin/Auth/Login', [
            'canResetPassword' => Route::has('admin.password.request'),
            'status' => session('status'),
        ]);
    }

    /**
     * Handle an incoming authentication request.
     */
    public function store(LoginRequest $request): RedirectResponse
    {
        Log::info('Admin login attempt', ['email' => $request->email]);

        try {
            $request->authenticate();
            $request->session()->regenerate();

            Log::info('Admin authenticated successfully', ['email' => $request->email]);

            return redirect()->intended(route('admin.dashboard'));
        } catch (\Exception $e) {
            Log::error('Admin authentication failed', ['email' => $request->email, 'error' => $e->getMessage()]);
            return back()->withErrors(['email' => 'The provided credentials do not match our records.']);
        }
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Log::info('Admin logout', ['user' => Auth::guard('admin')->user()->email]);

        Auth::guard('admin')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}


==== app\Http\Controllers\Admin\Auth\EmailVerificationNotificationController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('admin.dashboard', absolute: false));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}


==== app\Http\Controllers\Admin\Auth\EmailVerificationPromptController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;

class EmailVerificationPromptController extends Controller
{
    /**
     * Display the email verification prompt.
     */
    public function __invoke(Request $request): RedirectResponse|Response
    {
        return $request->user()->hasVerifiedEmail()
            ? redirect()->intended(route('dashboard', absolute: false))
            : Inertia::render('Admin/Auth/VerifyEmail', ['status' => session('status')]);
    }
}


==== app\Http\Controllers\Admin\Auth\NewPasswordController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

class NewPasswordController extends Controller
{
    /**
     * Display the password reset view.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('Admin/Auth/ResetPassword', [
            'email' => $request->email,
            'token' => $request->route('token'),
        ]);
    }

    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => 'required',
            'email' => 'required|email',
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::broker('admins')->reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        if ($status == Password::PASSWORD_RESET) {
            return redirect()->route('admin.login')->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [trans($status)],
        ]);
    }
}


==== app\Http\Controllers\Admin\Auth\PasswordController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules\Password;

class PasswordController extends Controller
{
    /**
     * Update the admin user's password.
     */
    public function update(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'current_password' => ['required', 'current_password'],
            'password' => ['required', Password::defaults(), 'confirmed'],
        ]);

        $request->user()->update([
            'password' => Hash::make($validated['password']),
        ]);

        return back();
    }
}


==== app\Http\Controllers\Admin\Auth\PasswordResetLinkController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Password;
use Illuminate\Validation\ValidationException;

class PasswordResetLinkController extends Controller
{
    /**
     * Display the password reset link request view.
     */
    public function create(): Response
    {
        return Inertia::render('Admin/Auth/ForgotPassword', [
            'status' => session('status'),
        ]);
    }

    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::broker('admins')->sendResetLink(
            $request->only('email')
        );

        if ($status == Password::RESET_LINK_SENT) {
            return back()->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [trans($status)],
        ]);
    }
}


==== app\Http\Controllers\Admin\Auth\VerifyEmailController.php ====

<?php

namespace App\Http\Controllers\Admin\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\Verified;
use Illuminate\Http\RedirectResponse;
use Illuminate\Foundation\Auth\EmailVerificationRequest;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('admin.dashboard', absolute: false) . '?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('admin.dashboard', absolute: false) . '?verified=1');
    }
}


==== app\Http\Controllers\Admin\ProfileController.php ====

<?php

namespace App\Http\Controllers\Admin;

use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\Auth;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Redirect;
use App\Http\Requests\Admin\ProfileUpdateRequest;
use Illuminate\Contracts\Auth\MustVerifyEmail;

class ProfileController extends Controller
{
    /**
     * Display the admin user's profile form.
     */
    public function edit(Request $request): Response
    {
        return Inertia::render('Admin/Profile/Edit', [
            'mustVerifyEmail' => $request->user() instanceof MustVerifyEmail,
            'status' => session('status'),
        ]);
    }

    /**
     * Update the admin user's profile information.
     */
    public function update(ProfileUpdateRequest $request): RedirectResponse
    {
        $request->user()->fill($request->validated());

        if ($request->user()->isDirty('email')) {
            $request->user()->email_verified_at = null;
        }

        $request->user()->save();

        return Redirect::route('admin.profile.edit');
    }

    /**
     * Delete the admin user's account.
     */
    public function destroy(Request $request): RedirectResponse
    {
        $request->validate([
            'password' => ['required', 'current_password'],
        ]);

        $user = $request->user();

        Auth::guard('admin')->logout();

        $user->delete();

        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect()->route('welcome');
    }
}


==== app\Http\Controllers\Admin\UserController.php ====

<?php

namespace App\Http\Controllers\Admin;

use App\DataTransferObjects\UserFiltersDto;
use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;
use App\Services\UserService;

class UserController extends Controller
{
    public function __construct(public UserService $userService)
    {
    }

    public function index(Request $request): Response
    {
        $users = $this->userService->getUsers(
            UserFiltersDto::fromDataTableRequest($request)
        );

        return Inertia::render('Admin/Users/Index', [
            'urlParams' => $request->all(),
            'users' => $users,
        ]);
    }
}


==== app\Http\Controllers\Auth\AuthenticatedSessionController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Http\Requests\Auth\LoginRequest;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Route;
use Inertia\Inertia;
use Inertia\Response;

class AuthenticatedSessionController extends Controller
{
    /**
     * Display the login view.
     */
    public function create(): Response
    {
        return Inertia::render('Auth/Login', [
            'canResetPassword' => Route::has('password.request'),
            'status' => session('status'),
        ]);
    }

    /**
     * Handle an incoming authentication request.
     */
    public function store(LoginRequest $request): RedirectResponse
    {
        $request->authenticate();

        $request->session()->regenerate();

        return redirect()->intended(route('dashboard', absolute: false));
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}


==== app\Http\Controllers\Auth\EmailVerificationNotificationController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}


==== app\Http\Controllers\Auth\EmailVerificationPromptController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

class EmailVerificationPromptController extends Controller
{
    /**
     * Display the email verification prompt.
     */
    public function __invoke(Request $request): RedirectResponse|Response
    {
        return $request->user()->hasVerifiedEmail()
            ? redirect()->intended(route('dashboard', absolute: false))
            : Inertia::render('Auth/VerifyEmail', ['status' => session('status')]);
    }
}


==== app\Http\Controllers\Auth\NewPasswordController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

class NewPasswordController extends Controller
{
    /**
     * Display the password reset view.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('Auth/ResetPassword', [
            'email' => $request->email,
            'token' => $request->route('token'),
        ]);
    }

    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => 'required',
            'email' => 'required|email',
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        if ($status == Password::PASSWORD_RESET) {
            return redirect()->route('login')->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [trans($status)],
        ]);
    }
}


==== app\Http\Controllers\Auth\PasswordController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules\Password;

class PasswordController extends Controller
{
    /**
     * Update the user's password.
     */
    public function update(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'current_password' => ['required', 'current_password'],
            'password' => ['required', Password::defaults(), 'confirmed'],
        ]);

        $request->user()->update([
            'password' => Hash::make($validated['password']),
        ]);

        return back();
    }
}


==== app\Http\Controllers\Auth\PasswordResetLinkController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

class PasswordResetLinkController extends Controller
{
    /**
     * Display the password reset link request view.
     */
    public function create(): Response
    {
        return Inertia::render('Auth/ForgotPassword', [
            'status' => session('status'),
        ]);
    }

    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        if ($status == Password::RESET_LINK_SENT) {
            return back()->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [trans($status)],
        ]);
    }
}


==== app\Http\Controllers\Auth\RegisteredUserController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Inertia\Inertia;
use Inertia\Response;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): Response
    {
        return Inertia::render('Auth/Register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'lowercase', 'email', 'max:255', 'unique:' . User::class],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard', absolute: false));
    }
}


==== app\Http\Controllers\Auth\VerifyEmailController.php ====

<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false) . '?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('dashboard', absolute: false) . '?verified=1');
    }
}


==== app\Http\Controllers\Controller.php ====

<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


==== app\Http\Controllers\ProfileController.php ====

<?php

namespace App\Http\Controllers;

use App\Http\Requests\ProfileUpdateRequest;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Redirect;
use Inertia\Inertia;
use Inertia\Response;

class ProfileController extends Controller
{
    /**
     * Display the user's profile form.
     */
    public function edit(Request $request): Response
    {
        return Inertia::render('Profile/Edit', [
            'mustVerifyEmail' => $request->user() instanceof MustVerifyEmail,
            'status' => session('status'),
        ]);
    }

    /**
     * Update the user's profile information.
     */
    public function update(ProfileUpdateRequest $request): RedirectResponse
    {
        $request->user()->fill($request->validated());

        if ($request->user()->isDirty('email')) {
            $request->user()->email_verified_at = null;
        }

        $request->user()->save();

        return Redirect::route('profile.edit');
    }

    /**
     * Delete the user's account.
     */
    public function destroy(Request $request): RedirectResponse
    {
        $request->validate([
            'password' => ['required', 'current_password'],
        ]);

        $user = $request->user();

        Auth::logout();

        $user->delete();

        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect()->route('welcome');
    }
}


==== app\Http\Controllers\PurchaseOrderController.php ====

<?php

namespace App\Http\Controllers;

use App\DataTransferObjects\PurchaseOrderFiltersDto;
use App\Http\Requests\StorePurchaseOrderRequest;
use App\Services\PurchaseOrderService;
use App\DTOs\SupplierAddressesDTO;
use App\Models\Supplier;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Inertia\Inertia;
use Inertia\Response;

class PurchaseOrderController extends Controller
{
    public function __construct(protected PurchaseOrderService $purchaseOrderService) {}

    public function create(): Response
    {
        // Get self supplier (Doner Industries)
        $selfSupplier = Supplier::where('account_number', 'DI')->firstOrFail();
        Log::info('Self supplier found: ', ['supplier' => $selfSupplier->toArray()]);

        // Get all suppliers for selection
        $suppliers = Supplier::query()
            ->with(['parts' => function ($query) {
                $query->select([
                    'id',
                    'supplier_id',
                    'part_number',
                    'description',
                    'replenishment_data'
                ])->whereNotNull('replenishment_data');
            }])
            ->select([
                'id',
                'name',
                'account_number',
                'addresses'
            ])
            ->whereNull('deleted_at')
            ->get();

        // Get available addresses from self supplier
        $availableAddresses = [
            'billTo' => $selfSupplier->getBillToAddresses(),
            'shipTo' => $selfSupplier->getShipToAddresses(),
        ];

        Log::info('Available addresses:', $availableAddresses);

        return Inertia::render('PurchaseOrders/CreatePurchaseOrder', [
            'initialData' => [
                'availableSuppliers' => $suppliers,
                'defaultTaxRate' => config('purchase_orders.default_tax_rate', 8.25),
                'settings' => [
                    'minQuantity' => 0,
                    'defaultLeadDays' => 0,
                    'requireShippingAddress' => true,
                ],
                'defaultAddresses' => $availableAddresses
            ]
        ]);
    }

    public function index(Request $request): Response
    {
        try {
            $filters = PurchaseOrderFiltersDto::fromDataTableRequest($request);
            $purchaseOrders = $this->purchaseOrderService->getPurchaseOrders($filters);

            return Inertia::render('PurchaseOrders/Index', [
                'urlParams' => $request->all(),
                'purchaseOrders' => $purchaseOrders,
                'filters' => $filters
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to load purchase orders', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return Inertia::render('PurchaseOrders/Index', [
                'urlParams' => $request->all(),
                'purchaseOrders' => [
                    'data' => [],
                    'total' => 0
                ],
                'error' => 'Failed to load purchase orders'
            ]);
        }
    }

    private function cleanAddressData($addresses)
    {
        $cleaned = [];
        foreach ($addresses as $type => $address) {
            if ($address) {
                // If address has a 'value' property (from select component), use that
                $addressData = isset($address['value']) ? $address['value'] : $address;

                // Clean up the address data to only include valid fields
                $cleanedAddress = array_intersect_key($addressData, array_flip([
                    'street1',
                    'street2',
                    'city',
                    'state',
                    'postal_code',
                    'country',
                    'type',
                    'address1',
                    'address2',
                    'state_prov_code',
                    'zip',
                    'phone_number',
                    'email_address'
                ]));

                // Wrap single address in array for DTO
                $cleaned[$type] = [$cleanedAddress];
            } else {
                $cleaned[$type] = [];
            }
        }

        return $cleaned;
    }

    public function store(StorePurchaseOrderRequest $request)
    {
        try {
            $validatedData = $request->validated();
            Log::info('Validated data:', $validatedData);

            // Clean up address data
            $validatedData['addresses'] = $this->cleanAddressData($validatedData['addresses']);
            Log::info('Cleaned addresses:', $validatedData['addresses']);

            $validatedData['addresses'] = SupplierAddressesDTO::fromArray($validatedData['addresses']);
            $purchaseOrder = $this->purchaseOrderService->createPurchaseOrder($validatedData);

            return redirect()
                ->route('purchase-orders.show', $purchaseOrder->id)
                ->with('success', 'Purchase order created successfully.');
        } catch (\Exception $e) {
            Log::error('Failed to create purchase order', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'data' => $validatedData ?? null
            ]);

            return back()->withErrors(['error' => 'Failed to create purchase order']);
        }
    }

    public function draft(StorePurchaseOrderRequest $request)
    {
        try {
            $validatedData = $request->validated();
            Log::info('Validated draft data:', $validatedData);

            // Clean up address data
            $validatedData['addresses'] = $this->cleanAddressData($validatedData['addresses']);
            Log::info('Cleaned addresses:', $validatedData['addresses']);

            $validatedData['addresses'] = SupplierAddressesDTO::fromArray($validatedData['addresses']);
            $purchaseOrder = $this->purchaseOrderService->saveDraft($validatedData);

            return redirect()
                ->route('purchase-orders.show', $purchaseOrder->id)
                ->with('success', 'Purchase order draft saved successfully.');
        } catch (\Exception $e) {
            Log::error('Failed to save purchase order draft', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'data' => $validatedData ?? null
            ]);

            return back()->withErrors(['error' => 'Failed to save draft']);
        }
    }

    public function show($id): Response
    {
        try {
            $purchaseOrder = $this->purchaseOrderService->getPurchaseOrder($id);

            return Inertia::render('PurchaseOrders/ShowPurchaseOrder', [
                'purchaseOrder' => $purchaseOrder
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to load purchase order', [
                'id' => $id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return redirect()
                ->route('purchase-orders.index')
                ->with('error', 'Purchase order not found');
        }
    }
}


==== app\Http\Controllers\PurchaseOrderController.php ====

<?php

namespace App\Http\Controllers;

use App\DataTransferObjects\PurchaseOrderFiltersDto;
use App\Http\Requests\StorePurchaseOrderRequest;
use App\Services\PurchaseOrderService;
use App\DTOs\SupplierAddressesDTO;
use App\Models\Supplier;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Inertia\Inertia;
use Inertia\Response;

class PurchaseOrderController extends Controller
{
    public function __construct(protected PurchaseOrderService $purchaseOrderService) {}

    public function create(): Response
    {
        // Get self supplier (Doner Industries)
        $selfSupplier = Supplier::where('account_number', 'DI')->firstOrFail();
        Log::info('Self supplier found: ', ['supplier' => $selfSupplier->toArray()]);

        // Get all suppliers for selection
        $suppliers = Supplier::query()
            ->with(['parts' => function ($query) {
                $query->select([
                    'id',
                    'supplier_id',
                    'part_number',
                    'description',
                    'replenishment_data'
                ])->whereNotNull('replenishment_data');
            }])
            ->select([
                'id',
                'name',
                'account_number',
                'addresses'
            ])
            ->whereNull('deleted_at')
            ->get();

        // Get available addresses from self supplier
        $availableAddresses = [
            'billTo' => $selfSupplier->getBillToAddresses(),
            'shipTo' => $selfSupplier->getShipToAddresses(),
        ];

        Log::info('Available addresses:', $availableAddresses);

        return Inertia::render('PurchaseOrders/CreatePurchaseOrder', [
            'initialData' => [
                'availableSuppliers' => $suppliers,
                'defaultTaxRate' => config('purchase_orders.default_tax_rate', 8.25),
                'settings' => [
                    'minQuantity' => 0,
                    'defaultLeadDays' => 0,
                    'requireShippingAddress' => true,
                ],
                'defaultAddresses' => $availableAddresses
            ]
        ]);
    }

    public function index(Request $request): Response
    {
        try {
            $filters = PurchaseOrderFiltersDto::fromDataTableRequest($request);
            $purchaseOrders = $this->purchaseOrderService->getPurchaseOrders($filters);

            return Inertia::render('PurchaseOrders/Index', [
                'urlParams' => $request->all(),
                'purchaseOrders' => $purchaseOrders,
                'filters' => $filters
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to load purchase orders', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return Inertia::render('PurchaseOrders/Index', [
                'urlParams' => $request->all(),
                'purchaseOrders' => [
                    'data' => [],
                    'total' => 0
                ],
                'error' => 'Failed to load purchase orders'
            ]);
        }
    }

    private function cleanAddressData($addresses)
    {
        $cleaned = [];
        foreach ($addresses as $type => $address) {
            if ($address) {
                // If address has a 'value' property (from select component), use that
                $addressData = isset($address['value']) ? $address['value'] : $address;

                // Clean up the address data to only include valid fields
                $cleanedAddress = array_intersect_key($addressData, array_flip([
                    'street1',
                    'street2',
                    'city',
                    'state',
                    'postal_code',
                    'country',
                    'type',
                    'address1',
                    'address2',
                    'state_prov_code',
                    'zip',
                    'phone_number',
                    'email_address'
                ]));

                // Wrap single address in array for DTO
                $cleaned[$type] = [$cleanedAddress];
            } else {
                $cleaned[$type] = [];
            }
        }

        return $cleaned;
    }

    public function store(StorePurchaseOrderRequest $request)
    {
        try {
            $validatedData = $request->validated();
            Log::info('Validated data:', $validatedData);

            // Clean up address data
            $validatedData['addresses'] = $this->cleanAddressData($validatedData['addresses']);
            Log::info('Cleaned addresses:', $validatedData['addresses']);

            $validatedData['addresses'] = SupplierAddressesDTO::fromArray($validatedData['addresses']);
            $purchaseOrder = $this->purchaseOrderService->createPurchaseOrder($validatedData);

            return redirect()
                ->route('purchase-orders.show', $purchaseOrder->id)
                ->with('success', 'Purchase order created successfully.');
        } catch (\Exception $e) {
            Log::error('Failed to create purchase order', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'data' => $validatedData ?? null
            ]);

            return back()->withErrors(['error' => 'Failed to create purchase order']);
        }
    }

    public function draft(StorePurchaseOrderRequest $request)
    {
        try {
            $validatedData = $request->validated();
            Log::info('Validated draft data:', $validatedData);

            // Clean up address data
            $validatedData['addresses'] = $this->cleanAddressData($validatedData['addresses']);
            Log::info('Cleaned addresses:', $validatedData['addresses']);

            $validatedData['addresses'] = SupplierAddressesDTO::fromArray($validatedData['addresses']);
            $purchaseOrder = $this->purchaseOrderService->saveDraft($validatedData);

            return redirect()
                ->route('purchase-orders.show', $purchaseOrder->id)
                ->with('success', 'Purchase order draft saved successfully.');
        } catch (\Exception $e) {
            Log::error('Failed to save purchase order draft', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'data' => $validatedData ?? null
            ]);

            return back()->withErrors(['error' => 'Failed to save draft']);
        }
    }

    public function show($id): Response
    {
        try {
            $purchaseOrder = $this->purchaseOrderService->getPurchaseOrder($id);

            return Inertia::render('PurchaseOrders/ShowPurchaseOrder', [
                'purchaseOrder' => $purchaseOrder
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to load purchase order', [
                'id' => $id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return redirect()
                ->route('purchase-orders.index')
                ->with('error', 'Purchase order not found');
        }
    }
}


==== app\Services\PurchaseOrderService.php ====

<?php

namespace App\Services;

use App\DataTransferObjects\PurchaseOrderFiltersDto;
use App\Models\PurchaseOrder;
use App\Models\PurchaseOrderPart;
use App\Models\Product;
use App\Models\BillOfMaterial;
use App\DTOs\SupplierAddressesDTO;
use App\Enums\PurchaseOrderStatus;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class PurchaseOrderService
{
    public function getPurchaseOrders(PurchaseOrderFiltersDto $filters): mixed
    {
        $query = PurchaseOrder::query()
            ->with(['supplier', 'user'])
            ->when($filters->number, function (Builder $query) use ($filters) {
                $query->where('number', 'like', "%{$filters->number}%");
            })
            ->when($filters->supplier, function (Builder $query) use ($filters) {
                $query->whereHas('supplier', function ($q) use ($filters) {
                    $q->where('name', 'like', "%{$filters->supplier}%");
                });
            })
            ->when($filters->status, function (Builder $query) use ($filters) {
                $query->where('status', $filters->status);
            })
            ->when($filters->created_at, function (Builder $query) use ($filters) {
                $query->whereDate('created_at', $filters->created_at);
            })
            ->when($filters->total_cost, function (Builder $query) use ($filters) {
                $query->where('total_cost', 'like', "%{$filters->total_cost}%");
            })
            ->when($filters->user_name, function (Builder $query) use ($filters) {
                $query->whereHas('user', function ($q) use ($filters) {
                    $q->where('name', 'like', "%{$filters->user_name}%");
                });
            });

        if ($filters->sortField && $filters->sortDirection) {
            if ($filters->sortField === 'supplier.name') {
                $query->join('suppliers', 'purchase_orders.supplier_id', '=', 'suppliers.id')
                    ->orderBy('suppliers.name', $filters->sortDirection);
            } elseif ($filters->sortField === 'user.name') {
                $query->join('users', 'purchase_orders.user_id', '=', 'users.id')
                    ->orderBy('users.name', $filters->sortDirection);
            } else {
                $query->orderBy($filters->sortField, $filters->sortDirection);
            }
        } else {
            $query->orderBy('created_at', 'desc');
        }

        return ($filters->perPage && $filters->currentPage)
            ? $query->paginate(perPage: $filters->perPage, page: $filters->currentPage)
            : $query->get();
    }

    public function createPurchaseOrder(array $data, bool $isDraft = false): PurchaseOrder
    {
        Log::info('Creating purchase order with data:', $data);

        return DB::transaction(function () use ($data, $isDraft) {
            try {
                // Create the purchase order
                $purchaseOrder = PurchaseOrder::create([
                    'number' => $data['number'],
                    'supplier_id' => $data['supplier_id'],
                    'location_id' => $data['location_id'] ?? 1,
                    'addresses' => $data['addresses'],
                    'special_instructions' => $data['special_instructions'] ?? null,
                    'tax_rate' => $data['tax_rate'] ?? config('purchase_orders.default_tax_rate', 8.25),
                    'additional_costs' => round($data['additional_costs'] ?? 0.00, 2),
                    'total_cost' => round($data['total_cost'], 2),
                    'user_id' => Auth::id(),
                    'status' => $data['status'] ?? ($isDraft ? PurchaseOrderStatus::DRAFT : PurchaseOrderStatus::SUBMITTED),
                ]);

                Log::info('Created purchase order:', ['id' => $purchaseOrder->id]);

                // Create purchase order parts
                foreach ($data['parts'] as $part) {
                    PurchaseOrderPart::create([
                        'purchase_order_id' => $purchaseOrder->id,
                        'part_id' => $part['part_id'],
                        'quantity_ordered' => $part['quantity_ordered'],
                        'unit_cost' => round($part['unit_cost'], 2),
                        'total_cost' => round($part['total_cost'], 2),
                    ]);
                }

                Log::info('Created purchase order parts');

                // Calculate totals including tax and additional costs
                $purchaseOrder->calculateTotals();
                $purchaseOrder->save();

                Log::info('Calculated totals and saved purchase order');

                return $purchaseOrder->load(['supplier', 'location', 'parts.part']);
            } catch (\Exception $e) {
                Log::error('Failed to create purchase order', [
                    'error' => $e->getMessage(),
                    'trace' => $e->getTraceAsString(),
                    'data' => $data
                ]);
                throw $e;
            }
        });
    }

    public function saveDraft(array $data): PurchaseOrder
    {
        return $this->createPurchaseOrder($data, true);
    }

    public function getPurchaseOrder($id): PurchaseOrder
    {
        return PurchaseOrder::with(['supplier', 'location', 'parts.part'])->findOrFail($id);
    }

    public function calculateOrderTotals(array $parts, float $taxRate, float $additionalCosts): array
    {
        $subtotal = collect($parts)->sum(function ($part) {
            return round($part['quantity_ordered'] * $part['unit_cost'], 2);
        });

        $taxAmount = round($subtotal * ($taxRate / 100), 2);
        $totalCost = round($subtotal + $taxAmount + $additionalCosts, 2);

        return [
            'subtotal' => $subtotal,
            'tax_amount' => $taxAmount,
            'total_cost' => $totalCost
        ];
    }

    /**
     * Calculate required parts from a list of products and their quantities
     *
     * @param array|Collection $products Array or Collection of product_id => quantity pairs
     * @return array Array of calculated part requirements
     */
    public function fromProducts(array|Collection $products): array
    {
        // Convert array to collection if needed
        $products = is_array($products) ? collect($products) : $products;

        Log::info('Calculating parts for products:', $products->toArray());

        // Get all products with their bill of materials
        $productModels = Product::with(['billOfMaterials.part.supplier'])
            ->whereIn('id', $products->keys())
            ->get();

        Log::info('Found products:', ['count' => $productModels->count()]);

        // Initialize parts collection to store required quantities
        $requiredParts = collect();

        // Calculate required quantities for each part
        foreach ($productModels as $product) {
            $productQuantity = $products[$product->id];

            Log::info('Processing product:', [
                'product_id' => $product->id,
                'quantity' => $productQuantity,
                'bom_count' => $product->billOfMaterials->count()
            ]);

            foreach ($product->billOfMaterials as $bom) {
                $partId = $bom->part_id;
                $requiredQuantity = $bom->quantity_required * $productQuantity;

                // Add to or update required parts collection
                if ($requiredParts->has($partId)) {
                    $requiredParts[$partId] = [
                        'part' => $bom->part,
                        'quantity' => $requiredParts[$partId]['quantity'] + $requiredQuantity,
                        'products' => $requiredParts[$partId]['products']->push([
                            'product_id' => $product->id,
                            'product_quantity' => $productQuantity,
                            'quantity_per_product' => $bom->quantity_required,
                            'subtotal_quantity' => $requiredQuantity
                        ])
                    ];
                } else {
                    $requiredParts[$partId] = [
                        'part' => $bom->part,
                        'quantity' => $requiredQuantity,
                        'products' => collect([[
                            'product_id' => $product->id,
                            'product_quantity' => $productQuantity,
                            'quantity_per_product' => $bom->quantity_required,
                            'subtotal_quantity' => $requiredQuantity
                        ]])
                    ];
                }
            }
        }

        // Group parts by supplier
        $partsBySupplier = $requiredParts->groupBy(function ($item) {
            return $item['part']->supplier_id;
        });

        // Log the results
        foreach ($partsBySupplier as $supplierId => $parts) {
            $supplierName = $parts->first()['part']->supplier->name ?? 'Unknown Supplier';

            Log::info("Parts needed from supplier: $supplierName", [
                'supplier_id' => $supplierId,
                'parts' => $parts->map(function ($item) {
                    $unitCost = round($item['part']->unit_cost, 2);
                    $totalCost = round($item['quantity'] * $unitCost, 2);

                    return [
                        'part_number' => $item['part']->part_number,
                        'description' => $item['part']->description,
                        'total_quantity' => $item['quantity'],
                        'unit_cost' => $unitCost,
                        'total_cost' => $totalCost,
                        'used_in_products' => $item['products']->map(function ($usage) {
                            return [
                                'product_id' => $usage['product_id'],
                                'quantity' => $usage['product_quantity'],
                                'quantity_per_unit' => $usage['quantity_per_product']
                            ];
                        })->toArray()
                    ];
                })->toArray()
            ]);
        }

        $totalCost = round($requiredParts->sum(function ($item) {
            return $item['quantity'] * $item['part']->unit_cost;
        }), 2);

        return [
            'parts_by_supplier' => $partsBySupplier->toArray(),
            'total_suppliers' => $partsBySupplier->count(),
            'total_parts' => $requiredParts->count(),
            'total_cost' => $totalCost
        ];
    }
}
